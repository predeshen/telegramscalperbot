"""
Signal Diagnostics System
Tracks detection attempts, filter rejections, and data quality issues
"""
import logging
from datetime import datetime, timedelta
from collections import defaultdict
from typing import Dict, List, Optional
from dataclasses import dataclass


logger = logging.getLogger(__name__)


@dataclass
class DiagnosticReport:
    """Diagnostic report data model"""
    scanner_name: str
    runtime_hours: float
    last_signal_time: Optional[datetime]
    detection_attempts: Dict[str, int]  # strategy -> count
    successful_detections: Dict[str, int]  # strategy -> count
    filter_rejections: Dict[str, int]  # reason -> count
    data_quality_issues: Dict[str, int]  # issue -> count
    recommendations: List[str]
    
    def to_telegram_message(self) -> str:
        """Format as Telegram message"""
        msg = f"üìä <b>Diagnostic Report: {self.scanner_name}</b>\n\n"
        msg += f"‚è± Runtime: {self.runtime_hours:.1f}h\n"
        msg += f"üéØ Last Signal: {self.last_signal_time.strftime('%H:%M') if self.last_signal_time else 'Never'}\n\n"
        
        # Top 3 strategies by attempts
        if self.detection_attempts:
            top_strategies = sorted(self.detection_attempts.items(), key=lambda x: x[1], reverse=True)[:3]
            msg += "<b>Detection Attempts:</b>\n"
            for strategy, count in top_strategies:
                success = self.successful_detections.get(strategy, 0)
                rate = (success / count * 100) if count > 0 else 0
                msg += f"  ‚Ä¢ {strategy}: {count} ({rate:.0f}% success)\n"
        
        # Top 3 rejection reasons
        if self.filter_rejections:
            top_rejections = sorted(self.filter_rejections.items(), key=lambda x: x[1], reverse=True)[:3]
            msg += "\n<b>Top Rejection Reasons:</b>\n"
            for reason, count in top_rejections:
                msg += f"  ‚Ä¢ {reason}: {count}\n"
        
        # Data quality issues
        if self.data_quality_issues:
            total_issues = sum(self.data_quality_issues.values())
            msg += f"\n<b>Data Quality Issues:</b> {total_issues}\n"
        
        # Recommendations
        if self.recommendations:
            msg += "\n<b>Recommendations:</b>\n"
            for rec in self.recommendations[:3]:
                msg += f"  {rec}\n"
        
        return msg


class SignalDiagnostics:
    """
    Comprehensive diagnostic system for signal detection analysis
    """
    
    def __init__(self, scanner_name: str):
        """
        Initialize diagnostics tracker
        
        Args:
            scanner_name: Name of the scanner (e.g., "BTC-Scalp", "US30-Momentum")
        """
        self.scanner_name = scanner_name
        self.detection_attempts = defaultdict(int)  # strategy -> count
        self.successful_detections = defaultdict(int)  # strategy -> count
        self.filter_rejections = defaultdict(int)  # reason -> count
        self.data_quality_issues = defaultdict(int)  # issue_type -> count
        self.last_signal_time: Optional[datetime] = None
        self.start_time = datetime.now()
        
        logger.info(f"SignalDiagnostics initialized for {scanner_name}")
    
    def log_detection_attempt(self, strategy: str, success: bool, reason: str = ""):
        """
        Log a strategy detection attempt
        
        Args:
            strategy: Strategy name (e.g., "EMA Crossover", "Trend Alignment")
            success: Whether detection was successful
            reason: Reason for failure (if not successful)
        """
        self.detection_attempts[strategy] += 1
        
        if success:
            self.successful_detections[strategy] += 1
            logger.debug(f"‚úì {strategy} detection successful")
        else:
            if reason:
                self.filter_rejections[reason] += 1
            logger.debug(f"‚úó {strategy} detection failed: {reason}")
    
    def log_signal_generated(self, strategy: str):
        """
        Log when a signal is successfully generated and sent
        
        Args:
            strategy: Strategy that generated the signal
        """
        self.last_signal_time = datetime.now()
        logger.info(f"‚úÖ Signal generated by {strategy} at {self.last_signal_time.strftime('%H:%M:%S')}")
    
    def log_data_quality_issue(self, issue_type: str):
        """
        Log a data quality problem
        
        Args:
            issue_type: Type of issue (e.g., "NaN in RSI", "Stale data", "Insufficient candles")
        """
        self.data_quality_issues[issue_type] += 1
        logger.warning(f"Data quality issue: {issue_type}")
    
    def generate_report(self) -> DiagnosticReport:
        """
        Generate diagnostic report
        
        Returns:
            DiagnosticReport with all tracked metrics
        """
        runtime = datetime.now() - self.start_time
        runtime_hours = runtime.total_seconds() / 3600
        
        recommendations = self.get_recommendations()
        
        report = DiagnosticReport(
            scanner_name=self.scanner_name,
            runtime_hours=runtime_hours,
            last_signal_time=self.last_signal_time,
            detection_attempts=dict(self.detection_attempts),
            successful_detections=dict(self.successful_detections),
            filter_rejections=dict(self.filter_rejections),
            data_quality_issues=dict(self.data_quality_issues),
            recommendations=recommendations
        )
        
        return report
    
    def generate_report_text(self) -> str:
        """
        Generate diagnostic report as formatted text
        
        Returns:
            Formatted diagnostic report string
        """
        runtime = datetime.now() - self.start_time
        
        report = f"""
=== Signal Detection Diagnostic Report ===
Scanner: {self.scanner_name}
Runtime: {runtime}
Last Signal: {self.last_signal_time or 'Never'}

Detection Attempts by Strategy:
"""
        
        if self.detection_attempts:
            for strategy, count in sorted(self.detection_attempts.items(), key=lambda x: x[1], reverse=True):
                success_count = self.successful_detections.get(strategy, 0)
                success_rate = (success_count / count * 100) if count > 0 else 0
                report += f"  {strategy}: {count} attempts, {success_count} successful ({success_rate:.1f}%)\n"
        else:
            report += "  No detection attempts recorded\n"
        
        report += "\nFilter Rejections:\n"
        if self.filter_rejections:
            for reason, count in sorted(self.filter_rejections.items(), key=lambda x: x[1], reverse=True):
                report += f"  {reason}: {count}\n"
        else:
            report += "  No rejections recorded\n"
        
        if self.data_quality_issues:
            report += "\nData Quality Issues:\n"
            for issue, count in sorted(self.data_quality_issues.items(), key=lambda x: x[1], reverse=True):
                report += f"  {issue}: {count}\n"
        
        recommendations = self.get_recommendations()
        if recommendations:
            report += "\nRecommendations:\n"
            for rec in recommendations:
                report += f"  {rec}\n"
        
        return report
    
    def get_recommendations(self) -> List[str]:
        """
        Generate recommendations based on diagnostic data
        
        Returns:
            List of actionable recommendation strings
        """
        recommendations = []
        
        # Check for low detection rates
        for strategy, attempts in self.detection_attempts.items():
            if attempts > 10:
                success_rate = self.successful_detections.get(strategy, 0) / attempts
                if success_rate < 0.05:  # Less than 5% success
                    recommendations.append(
                        f"‚ö†Ô∏è {strategy} has very low success rate ({success_rate*100:.1f}%). "
                        f"Consider relaxing thresholds."
                    )
        
        # Check for dominant rejection reasons
        total_rejections = sum(self.filter_rejections.values())
        if total_rejections > 0:
            for reason, count in self.filter_rejections.items():
                if count / total_rejections > 0.5:  # More than 50% of rejections
                    recommendations.append(
                        f"‚ö†Ô∏è '{reason}' is blocking {count/total_rejections*100:.0f}% of signals. "
                        f"Review this filter threshold."
                    )
        
        # Check for no signals
        runtime_hours = (datetime.now() - self.start_time).total_seconds() / 3600
        if self.last_signal_time is None and runtime_hours > 1:
            recommendations.append(
                "üö® No signals generated in over 1 hour. Consider enabling bypass mode for testing."
            )
        
        # Check for data quality issues
        total_data_issues = sum(self.data_quality_issues.values())
        if total_data_issues > 10:
            recommendations.append(
                f"‚ö†Ô∏è {total_data_issues} data quality issues detected. Check data source connection."
            )
        
        # Check for specific data issues
        if "NaN" in str(self.data_quality_issues):
            recommendations.append(
                "‚ö†Ô∏è NaN values detected in indicators. Verify indicator calculations."
            )
        
        if "Stale data" in str(self.data_quality_issues):
            recommendations.append(
                "‚ö†Ô∏è Stale data detected. Check data source latency and polling interval."
            )
        
        return recommendations
    
    def get_statistics(self) -> Dict:
        """
        Get diagnostic statistics as dictionary
        
        Returns:
            Dictionary with key metrics
        """
        runtime = datetime.now() - self.start_time
        runtime_hours = runtime.total_seconds() / 3600
        
        total_attempts = sum(self.detection_attempts.values())
        total_successes = sum(self.successful_detections.values())
        success_rate = (total_successes / total_attempts * 100) if total_attempts > 0 else 0
        
        return {
            'scanner_name': self.scanner_name,
            'runtime_hours': runtime_hours,
            'last_signal_time': self.last_signal_time,
            'total_detection_attempts': total_attempts,
            'total_successful_detections': total_successes,
            'overall_success_rate': success_rate,
            'total_filter_rejections': sum(self.filter_rejections.values()),
            'total_data_quality_issues': sum(self.data_quality_issues.values()),
            'strategies_attempted': len(self.detection_attempts),
            'unique_rejection_reasons': len(self.filter_rejections)
        }
    
    def reset(self):
        """Reset all diagnostic counters"""
        self.detection_attempts.clear()
        self.successful_detections.clear()
        self.filter_rejections.clear()
        self.data_quality_issues.clear()
        self.last_signal_time = None
        self.start_time = datetime.now()
        logger.info(f"Diagnostics reset for {self.scanner_name}")
    
    def get_time_since_last_signal(self) -> Optional[timedelta]:
        """
        Get time elapsed since last signal
        
        Returns:
            timedelta since last signal, or None if no signals yet
        """
        if self.last_signal_time is None:
            return None
        return datetime.now() - self.last_signal_time
    
    def should_alert_no_signals(self, threshold_hours: float = 4.0) -> bool:
        """
        Check if alert should be sent for no signals
        
        Args:
            threshold_hours: Hours without signals before alerting
            
        Returns:
            True if alert should be sent
        """
        runtime_hours = (datetime.now() - self.start_time).total_seconds() / 3600
        
        # Don't alert if scanner just started
        if runtime_hours < threshold_hours:
            return False
        
        # Alert if no signals at all
        if self.last_signal_time is None:
            return True
        
        # Alert if too long since last signal
        time_since_signal = self.get_time_since_last_signal()
        if time_since_signal and time_since_signal.total_seconds() / 3600 >= threshold_hours:
            return True
        
        return False


if __name__ == "__main__":
    # Example usage
    logging.basicConfig(level=logging.INFO)
    
    diagnostics = SignalDiagnostics("Test Scanner")
    
    # Simulate some detection attempts
    diagnostics.log_detection_attempt("EMA Crossover", False, "Volume too low")
    diagnostics.log_detection_attempt("EMA Crossover", False, "RSI out of range")
    diagnostics.log_detection_attempt("Trend Alignment", True)
    diagnostics.log_signal_generated("Trend Alignment")
    diagnostics.log_data_quality_issue("NaN in RSI")
    
    # Generate report
    print(diagnostics.generate_report_text())
    
    # Get statistics
    stats = diagnostics.get_statistics()
    print(f"\nStatistics: {stats}")
